<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Feather</title>

        <!-- CSS Styling -->
        <style>
            html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            }

            #c {
                width: 100%;
                height: 100%;
                display: block;
                cursor: none; /* hide the mouse icon */
            }

            /* Small UI Control Panel */
            #ui-hint {
                position: fixed;
                top: 12px;
                left: 12px;
                padding: 10px 12px;
                background: rgba(0, 0, 0, 0.45);
                color: #ffffff;
                font-family: system-ui, Arial, sans-serif;
                font-size: 13px;
                line-height: 1.4;
                border-radius: 6px;
                z-index: 10;
                pointer-events: none; /* doesn't block mouse input */
                backdrop-filter: blur(4px);
            }

        </style>

        <script type="importmap">
        {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
        }
        </script>

    </head>
    <body>
        <canvas id="c"></canvas>

        <!-- UI control panel content -->
        <div id="ui-hint">
            <strong>Controls</strong><br>
            R – Rain<br>
            S – Snow<br>
            T – Tornado<br>
            N – Night<br>
            M – Music<br>
            Mouse – Move Bird
        </div>


        <script type="module">
            // three.js imports
            import * as THREE from "three";
            import { OrbitControls } from "three/addons/controls/OrbitControls.js";
            import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";


            // basic setup
            let renderer, scene, camera, controls;

            // bird variables
            let birdGroup;
            let modelRoot = null;
            let leftwing = null;
            let rightwing = null;
            let baseLeftWingRoot = 0;
            let baseRightWingRoot = 0;
            let birdLoaded = false;
            let baseBirdHeight = 0;
            const FLAP_SPEED = 4.0;
            const FLAP_AMPLITUDE = Math.PI / 6; // max wing rotation angle
            const BOB_SPEED = 1.5; // bobbing speed for bird
            const BOB_AMPLITUDE = 0.6; // bobbing height

            const clock = new THREE.Clock(); // clock to give elapsed time in seconds

            // audio variables
            let audioListener, backgroundMusic; // audioListener is the "ears" in the scene
            let musicLoaded = false;
            let musicVolume = 0.4;
            let musicMuted = false;

            // ===== mouse-follow bird movement =====
            const mouseNDC = new THREE.Vector2(0, 0);    
            let baseBirdPos = new THREE.Vector3(0, 0, 0); // bird rest position (x,y,z)

            const FOLLOW = {
                maxX: 12,        // how far left/right the bird can move
                maxY: 4,         // how far up/down (added on top of bobbing)
                maxZ: 8,         // how far forward/back (optional depth drift)
                strength: 2.0,   // higher = snappier follow, lower = floatier
                zone: {          // only follow mouse inside this screen box
                    x0: 0.15, x1: 0.85,
                    y0: 0.15, y1: 0.85
                },
                tiltRoll: 0.35,  // radians (bank left/right)
                tiltPitch: 0.18  // radians (nose up/down)
            };

            // cloud variables
            let clouds = [];
            const NUM_CLOUDS = 2000;
            
            const cloudMats = [];

            let CLOUD_MIN_Z = -1500;
            let CLOUD_MAX_Z = 1500;
            const CLOUD_Z_HALFSPAN = 1500;

            const CLOUD_HEIGHT = 13.0; // typical cloud height
            const CLOUD_HEIGHT_VARIATION = 350.0;
            const CLOUD_SPREAD_X = 500; // how far clouds can appear to the left and right
            const CLOUD_SPEED_Z = 75.0;
            const CLOUD_SIZE_MULT = 2.6;
            const PUFF_RADIUS_MULT = 1.8;
            let lastTime = 0; // for computing time diff between frames 

            // rain variables
            let precipMode = "none"; // none || snow || rain
            let snowGroup = null;
            let rainGroup = null;
            const RAIN_COUNT = 750;
            const RAIN_AREA_XZ = 40; // how wide/deep the rain area is
            const RAIN_HEIGHT = 18; // how high above the scene raindrops start

            // tornado variables
            let tornadoes = [];

            const TORNADO = {
                LAYERS: 300, // # of circular layers
                HEIGHT: 26,
                BASE_RADIUS: 1.0,
                TOP_RADIUS: 7.0,
                THICKNESS: 0.22,
                OPACITY: 0.18,
                SEGMENTS: 32,
                POS: new THREE.Vector3(28, 0, -25)
            };

            // weather states
            const WEATHER = { CLEAR: "clear", RAIN: "rain", SNOW: "snow", TORNADO: "tornado", NIGHT: "night" };
            let weatherMode = WEATHER.CLEAR;

            let ambientLight, sunLight;

            const CLEAR_SKY = 0x87ceeb;
            const RAIN_SKY = 0x5f7f95;
            const SNOW_SKY = 0x7fb6d4;
            const TORNADO_SKY = 0x808080;
            const CLOUD_CLEAR = 0xffffff;
            const CLOUD_SNOW = 0xd6d6d6;
            const CLOUD_RAIN = 0x6a6a6a;
            const CLOUD_TORNADO = 0x808080;
            const CLOUD_OPACITY = 0.7;

            const LIGHTS = {
                clear: { ambient: 0.30, sun: 1.00 },
                snow: { ambient: 0.22, sun: 0.80 },
                rain: { ambient: 0.15, sun: 0.65 },
                tornado: { ambient: 0.18, sun: 0.55 },
                night: { ambient: 0.12, sun: 0.25 }
            };

            const SUN_LIGHT_COLOR = 0xfff2cc;
            const MOON_LIGHT_COLOR = 0xbfd9ff;   // cool moonlight tint

            // ===== smooth weather transitions =====
            const weatherNow = {
                sky: new THREE.Color(CLEAR_SKY),
                fog: new THREE.Color(CLEAR_SKY),
                cloud: new THREE.Color(CLOUD_CLEAR),
                ambient: LIGHTS.clear.ambient,
                sun: LIGHTS.clear.sun,
                sunColor: new THREE.Color(SUN_LIGHT_COLOR),
                stars: 0, 
                sunVis: 1,
                moonVis: 0
            };

            const weatherTarget = {
                sky: new THREE.Color(CLEAR_SKY),
                fog: new THREE.Color(CLEAR_SKY),
                cloud: new THREE.Color(CLOUD_CLEAR),
                ambient: LIGHTS.clear.ambient,
                sun: LIGHTS.clear.sun,
                sunColor: new THREE.Color(SUN_LIGHT_COLOR),
                stars: 0,
                sunVis: 1,
                moonVis: 0
            };

            const WEATHER_FADE_SPEED = 1.5; // bigger = faster fade


            // night variables
            let stars = null;

            const NIGHT_SKY = 0x03040a;
            const CLOUD_NIGHT = 0x2a2a2a;

            const MOON_CORE_COLOR = 0xe9f2ff;    // pale moon surface
            const MOON_HALO_COLOR = { r: 185, g: 215, b: 255 }; // bluish glow

            // shooting star vars
            let shootingStars = [];
            const SHOOTING_STAR_COUNT = 8;      // pool size
            

            const SHOOTING = {
                spawnChancePerSec: 1,          // made it high for more frequent shooting stars
                minLife: 0.6,
                maxLife: 1.2,
                minLen: 80,
                maxLen: 180,
                minSpeed: 900,
                maxSpeed: 1600,
                yDirMin: 0.25,                    // keep above horizon
                rMin: 1200,
                rMax: 2600,
            };

            init();
            animate();

            // keyboard control for bakcground music
            window.addEventListener('keydown', (event) => {
                if (!musicLoaded || !backgroundMusic) return;
                // toggle with m key
                if (event.key === 'm' || event.key === 'M') {
                    // if the music is not playing and it is not muted, then begin playing the music
                    if (!backgroundMusic.isPlaying && !musicMuted) {
                        backgroundMusic.play();
                        return;
                    }
                    // otherwise, mute the music
                    musicMuted = !musicMuted;
                    if (musicMuted) {
                        backgroundMusic.setVolume(0);
                    } else {
                        backgroundMusic.setVolume(musicVolume);
                        // if for some reason the music stopped, restart
                        if (!backgroundMusic.isPlaying) {
                            backgroundMusic.play();
                        }
                    }
                }
            });

            function frameObject(object3D, camera, controls, offset = 1.25) {
                const box = new THREE.Box3().setFromObject(object3D);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());

                // How far the camera needs to be to fit the object
                const maxDim = Math.max(size.x, size.y, size.z);
                const fov = THREE.MathUtils.degToRad(camera.fov);
                let cameraZ = Math.abs((maxDim / 2) / Math.tan(fov / 2)) * offset;

                // Put camera in front of the object (positive Z direction)
                camera.position.set(center.x, center.y, center.z + cameraZ);

                // Set near/far so it doesn't clip
                camera.near = cameraZ / 100;
                camera.far = cameraZ * 100;
                camera.updateProjectionMatrix();

                // Center the controls on the object
                controls.target.copy(center);
                controls.update();

                // Make sure the camera is actually looking at the center
                camera.lookAt(center);
            }

            function makeRadialTexture(size = 256, stops = [
                { t: 0.0, a: 1.0 },
                { t: 0.5, a: 0.2 },
                { t: 1.0, a: 0.0 },
            ], rgb = { r: 255, g: 247, b: 209 }) {

                const canvas = document.createElement("canvas");
                canvas.width = canvas.height = size;
                const ctx = canvas.getContext("2d");

                const cx = size / 2, cy = size / 2;
                const r = size / 2;

                const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
                for (const s of stops) {
                    grad.addColorStop(s.t, `rgba(${rgb.r},${rgb.g},${rgb.b},${s.a})`);
                }

                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, size, size);

                const tex = new THREE.CanvasTexture(canvas);
                tex.colorSpace = THREE.SRGBColorSpace;
                return tex;
            }


            function createSun(){
                const sun = new THREE.Group();

                // core disc
                const coreGeo = new THREE.SphereGeometry(1.5, 32, 16);
                const coreMat = new THREE.MeshStandardMaterial({
                    color: 0xfff7d1,
                    emissive: 0xfff7d1,
                    emissiveIntensity: 1.0,
                    depthTest: false,
                    depthWrite: false,
                    fog: false,
                });
                const core = new THREE.Mesh(coreGeo, coreMat);
                sun.add(core);

                // soft halo #1
                const haloTex1 = makeRadialTexture(256, [
                    { t: 0.0, a: 0.35 },
                    { t: 0.35, a: 0.18 },
                    { t: 1.0, a: 0.0 },
                ]);

                const haloMat1 = new THREE.MeshBasicMaterial({
                    map: haloTex1,
                    transparent: true,
                    depthTest: false,
                    depthWrite: false,
                    fog: false,
                    blending: THREE.AdditiveBlending,
                });
                const halo1 = new THREE.Mesh(new THREE.PlaneGeometry(8.0, 8.0), haloMat1);
                halo1.renderOrder = -1001; // behind clouds but with sun group
                sun.add(halo1);

                // soft halo #2, bigger and fainter
                const haloTex2 = makeRadialTexture(256, [
                    { t: 0.0, a: 0.18 },
                    { t: 0.25, a: 0.10 },
                    { t: 1.0, a: 0.0 },
                ]);

                const haloMat2 = new THREE.MeshBasicMaterial({
                    map: haloTex2,
                    transparent: true,
                    depthTest: false,
                    depthWrite: false,
                    fog: false,
                    blending: THREE.AdditiveBlending,
                });

                const halo2 = new THREE.Mesh(new THREE.PlaneGeometry(14.0, 14.0), haloMat2);
                halo2.renderOrder = -1002;
                sun.add(halo2);

                // make sure halos face the camera
                sun.userData.billboard = [halo1, halo2];
                sun.renderOrder = -1000;
                return sun;
            }

            function createMoon() {
                const moon = new THREE.Group();

                // moon "disc" (sphere looks fine at distance)
                const coreGeo = new THREE.SphereGeometry(1.2, 32, 16);
                const coreMat = new THREE.MeshStandardMaterial({
                    color: MOON_CORE_COLOR,
                    emissive: 0x111827,          // very subtle glow
                    emissiveIntensity: 0.25,
                    roughness: 0.95,
                    metalness: 0.0,
                    depthTest: false,
                    depthWrite: false,
                    fog: false,
                });

                const core = new THREE.Mesh(coreGeo, coreMat);
                moon.add(core);

                // halo (bluish, faint)
                const haloTex = makeRadialTexture(256, [
                    { t: 0.0, a: 0.22 },
                    { t: 0.30, a: 0.12 },
                    { t: 1.0, a: 0.0 },
                ], MOON_HALO_COLOR);

                const haloMat = new THREE.MeshBasicMaterial({
                    map: haloTex,
                    transparent: true,
                    depthTest: false,
                    depthWrite: false,
                    fog: false,
                    blending: THREE.AdditiveBlending,
                });

                const halo = new THREE.Mesh(new THREE.PlaneGeometry(10.0, 10.0), haloMat);
                halo.renderOrder = -1002;
                moon.add(halo);

                moon.userData.billboard = [halo];
                moon.renderOrder = -1001;
                moon.visible = false; // start hidden until NIGHT
                return moon;
            }

            function init() {
                const canvas = document.getElementById("c");

                // renderer
                renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true});
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(0x87ceeb, 1); // sky blue

                // scene
                scene = new THREE.Scene();

                // adding fog to the scene for fading distant objects
                scene.fog = new THREE.Fog(0x87ceeb, 50, 2000);

                // camera
                const fov = 60;
                const aspect = window.innerWidth / window.innerHeight;
                const near = 0.1;
                const far = 3000; // change this with cloud visibility
                camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
                camera.position.set(0, 2, 6);
                scene.add(camera);

                CLOUD_MIN_Z = camera.position.z - CLOUD_Z_HALFSPAN;
                CLOUD_MAX_Z = camera.position.z + CLOUD_Z_HALFSPAN;

                // =============== audio setup ===============
                audioListener = new THREE.AudioListener();
                camera.add(audioListener);

                backgroundMusic = new THREE.Audio(audioListener); // global audio object for background music
                const audioLoader = new THREE.AudioLoader();
                audioLoader.load(
                    'audio/Nujabes-Feather.mp3',
                    (buffer) => {
                        backgroundMusic.setBuffer(buffer); // assign audio data
                        backgroundMusic.setLoop(true);
                        backgroundMusic.setVolume(musicVolume);
                        musicLoaded = true;
                    },
                    undefined,
                    (error) => {
                        console.error("Error loading background music:", error);
                    }
                );
                // ==========================================

                // orbit controls (for debugging)
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.target.set(0, 2, 0);
                controls.update();

                // lights
                ambientLight = new THREE.AmbientLight(0xffffff, LIGHTS.clear.ambient);
                scene.add(ambientLight);

                sunLight = new THREE.DirectionalLight(SUN_LIGHT_COLOR, LIGHTS.clear.sun);
                sunLight.position.set(5, 10, 5);
                scene.add(sunLight);

                applyWeather(WEATHER.CLEAR);

                // create sun
                const sun = createSun();
                sun.position.set(-15, 20, -30);
                scene.add(sun);
                window.__sun = sun;

                const moon = createMoon();
                moon.position.set(18, 22, -40);
                scene.add(moon);
                window.__moon = moon;
                
                // create stars for night mode
                stars = createStars(5000);
                scene.add(stars);
                initShootingStars();

                //=============== create clouds ===============
                // build clouds at random positions in the sky
                for (let i = 0; i < NUM_CLOUDS; i++){
                    const cloud = createCloud(); // helper function
                    scene.add(cloud);
                    clouds.push(cloud);
                }
                //=============================================

                //=============== create snow & rain===============
                createSnow();
                if (snowGroup) {
                    snowGroup.visible = false; // start with no snow
                }

                createRain();

                //=============================================

                //=============== create tornado =================
                tornadoes = [
                    { group: createTornado(new THREE.Vector3(28, 0, -25)), pos: new THREE.Vector3(28, 0, -25), move: 1.0 }, // the first three tornadoes correspond to the three directly 
                    { group: createTornado(new THREE.Vector3(10, 0, -40)), pos: new THREE.Vector3(10, 0, -40), move: 0.8 }, // ahead of the bird.  top one is more right
                    { group: createTornado(new THREE.Vector3(-18, 0, -30)), pos: new THREE.Vector3(-18, 0, -30), move: 1.2 }, // this one is more left. move => higher = more 'violent' tornado; lower = more normal
                    { group: createTornado(new THREE.Vector3(-34, 0, 0)), pos: new THREE.Vector3(-34, 0, 0), move: 1.7 },
                    { group: createTornado(new THREE.Vector3(42, 0, 7)), pos: new THREE.Vector3(42, 0, 7), move: 0.5 },
                    { group: createTornado(new THREE.Vector3(25, 0, 29)), pos: new THREE.Vector3(25, 0, 29), move: 1.3 },
                    { group: createTornado(new THREE.Vector3(-34, 0, 0)), pos: new THREE.Vector3(-34, 0, 17), move: 2.4 },
                ];
                //=============================================

                //=============== bird geometry ===============
                birdGroup = new THREE.Group();
                scene.add(birdGroup);

                const loader = new GLTFLoader();
                loader.load(
                "Seagull.glb", // my personal altered seagull file
                (gltf) => {
                    const model = gltf.scene;
                    birdGroup.add(model);

                    modelRoot = model;
                    birdLoaded = true;

                    // Find the wings
                    leftwing = model.getObjectByName("Leftwing");
                    rightwing = model.getObjectByName("Rightwing");

                    console.log("Leftwing:", leftwing);
                    console.log("Rightwing:", rightwing);


                    const box = new THREE.Box3().setFromObject(model);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    model.position.sub(center);
                    // scale the object
                    const scale = 2.0 / Math.max(size.x, size.y, size.z);
                    model.scale.setScalar(scale);
                    model.rotation.y += 1.5;

                    const BIRD_HEIGHT = 13.0;
                    birdGroup.position.set(0, BIRD_HEIGHT, 0);
                    baseBirdHeight = birdGroup.position.y;
                    baseBirdPos.copy(birdGroup.position);

                    // proper scene framing
                    frameObject(birdGroup, camera, controls, 3.0);

                    camera.far = 8000;
                    camera.near = Math.min(camera.near, 0.1);
                    camera.updateProjectionMatrix();

                    for (const c of clouds) respawnCloud(c);

                    console.log("GLB loaded:", { size, center, scale }); // for debugging
                },
                undefined,
                (err) => console.error("GLB load error:", err) // for debugging
                );

                scene.add(birdGroup);

                //=============================================

                // handle resize
                window.addEventListener('resize', onWindowResize);

                // listen for keypress to toggle rain
                window.addEventListener('keydown', onKeyDown);

                window.addEventListener("pointermove", (e) => {
                const w = window.innerWidth;
                const h = window.innerHeight;

                const u = e.clientX / w; 
                const v = e.clientY / h; 

                // Only respond if mouse is inside the “control box”
                const inside =
                    (u >= FOLLOW.zone.x0 && u <= FOLLOW.zone.x1 &&
                    v >= FOLLOW.zone.y0 && v <= FOLLOW.zone.y1);

                if (!inside) {
                    // drift back toward center when mouse leaves the zone
                    mouseNDC.set(0, 0);
                    return;
                }

                // Convert to NDC: x -1..+1, y -1..+1 (invert Y so up is +)
                mouseNDC.x = (u * 2 - 1);
                mouseNDC.y = -(v * 2 - 1);
                });

            }

            // function to create clouds
            function createCloud() {
                const cloud = new THREE.Object3D(); // parent object for puff meshes

                // random # of puffs per cloud ( 3 - 5 )
                const numPuffs = 3 + Math.floor(Math.random() * 3);

                for (let i = 0; i < numPuffs; i++) {
                    // slight varied radius fo each puff
                    const radius = THREE.MathUtils.randFloat(0.3, 0.8) * PUFF_RADIUS_MULT;

                    const geo = new THREE.SphereGeometry(radius, 16, 12);
                    const mat = new THREE.MeshStandardMaterial({
                        color: CLOUD_CLEAR,
                        roughness: 0.9,
                        metalness: 0.0,
                        transparent: true,
                        opacity: CLOUD_OPACITY
                    });
                    cloudMats.push(mat);
                    const puff = new THREE.Mesh(geo, mat);

                    // random offsets so the puffs aren't symmetric 
                    puff.position.set(
                        (Math.random() - 0.5) * 1.6, // left/right 
                        (Math.random() - 0.5) * 0.4, // up/down 
                        (Math.random() - 0.5) * 0.6 // front/back 
                    );
                    cloud.add(puff);
                }

                // position the entire cloud somewhere in the sky
                cloud.position.set(
                    (Math.random() - 0.5) * CLOUD_SPREAD_X, // x spread
                    CLOUD_HEIGHT + (Math.random() - 0.5) * CLOUD_HEIGHT_VARIATION, // slight y variation
                    THREE.MathUtils.randFloat(CLOUD_MIN_Z, CLOUD_MAX_Z) // random depth
                );

                const sx = (1.5 + Math.random() * 2.0) * CLOUD_SIZE_MULT; // width
                const sy = (1.0 + Math.random() * 0.5) * CLOUD_SIZE_MULT; // height
                const sz = (1.0 + Math.random() * 0.3) * CLOUD_SIZE_MULT; // depth
                cloud.scale.set(sx, sy, sz);

                cloud.userData.speed = THREE.MathUtils.randFloat(0.5, 2.0); // each cloud moves at diff speeds
                cloud.userData.dir = Math.random() < 0.5 ? -1 : 1; // left or right

                return cloud;
            }

            function respawnCloud(cloud) {
                cloud.position.x = (Math.random() - 0.5) * CLOUD_SPREAD_X;
                cloud.position.y = baseBirdHeight + (Math.random() - 0.5) * CLOUD_HEIGHT_VARIATION;
                cloud.position.z = THREE.MathUtils.randFloat(CLOUD_MIN_Z, CLOUD_MAX_Z);

                const sx = (1.5 + Math.random() * 2.0) * CLOUD_SIZE_MULT; // width
                const sy = (1.0 + Math.random() * 0.5) * CLOUD_SIZE_MULT; // height
                const sz = (1.0 + Math.random() * 0.3) * CLOUD_SIZE_MULT; // depth
                cloud.scale.set(sx, sy, sz);

                cloud.userData.speed = THREE.MathUtils.randFloat(0.5, 2.0);
                cloud.userData.dir = Math.random() < 0.5 ? -1 : 1;
                cloud.userData.drift = THREE.MathUtils.randFloat(0.2, 1.2); // NEW

            }

            // function for the snow ( this was originally designed for the rain mode so there may be variable overlap )
            function createSnow() {
                snowGroup = new THREE.Group();
                // buffer geometry to hold positions of all snowflakes
                const positions = new Float32Array(RAIN_COUNT * 3);

                for (let i = 0; i < RAIN_COUNT; i++) {
                    const idx = i * 3;
                    // random x/z within a square area around origin
                    positions[idx + 0] = (Math.random() - 0.5) * RAIN_AREA_XZ; // x
                    positions[idx + 1] = Math.random() * RAIN_HEIGHT + 2; // y
                    positions[idx + 2] = (Math.random() - 0.5) * RAIN_AREA_XZ; // z
                }

                const snowGeo = new THREE.BufferGeometry();
                snowGeo.setAttribute(
                    'position',
                    new THREE.BufferAttribute(positions, 3)
                );

                const snowMat = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 0.06,     // screen space size of each snowflake
                    transparent: true,
                    opacity: 0.9
                })

                const snowPoints = new THREE.Points(snowGeo, snowMat);
                snowGroup.add(snowPoints);
                scene.add(snowGroup);
            }

            // function for the rain
            function createRain(){
                rainGroup = new THREE.Group();

                // each raindrop has two vertices, a start and end point
                const rainPositions = new Float32Array(RAIN_COUNT * 2 * 3);
                const speeds = new Float32Array(RAIN_COUNT);
                const lengths = new Float32Array(RAIN_COUNT);

                for (let i = 0; i < RAIN_COUNT; i++){
                    const x = (Math.random() - 0.5) * RAIN_AREA_XZ;
                    const y = Math.random() * RAIN_HEIGHT + 2;
                    const z = (Math.random() - 0.5) * RAIN_AREA_XZ;

                    speeds[i] = THREE.MathUtils.randFloat(18, 35); // faster than the snow
                    lengths[i] = THREE.MathUtils.randFloat(0.6, 1.6); // longer streak to more clearly identify as rain

                    // starting vertex
                    rainPositions[i * 6 + 0] = x;
                    rainPositions[i * 6 + 1] = y;
                    rainPositions[i * 6 + 2] = z;

                    // end vertex
                    rainPositions[i * 6 + 3] = x;
                    rainPositions[i * 6 + 4] = y;
                    rainPositions[i * 6 + 5] = z;
                }

                const rainGeo = new THREE.BufferGeometry();
                rainGeo.setAttribute("position", new THREE.BufferAttribute(rainPositions, 3));

                const rainMat = new THREE.LineBasicMaterial({
                    color: 0xddeeff,
                    transparent: true,
                    opacity: 0.65
                });

                const lines = new THREE.LineSegments(rainGeo, rainMat);
                rainGroup.add(lines);

                rainGroup.userData.speeds = speeds;
                rainGroup.userData.lengths = lengths;
                rainGroup.visible = false;
                scene.add(rainGroup);
            }

            // function for tornadoes
            function createTornado(pos) {
                const group = new THREE.Group();
                // tornadoGroup = new THREE.Group();

                const layers = TORNADO.LAYERS;
                const h = TORNADO.HEIGHT;

                // shared material
                const mat = new THREE.MeshBasicMaterial({
                    color: 0xe7e7e7,
                    transparent: true,
                    opacity: TORNADO.OPACITY,
                    depthWrite: false, // helps translucent stacking look nicer
                });

                for (let i = 0; i < layers; i++) {
                    const t = i / (layers - 1);
                    const y = t * h;

                    // the radius grows as you go higher
                    const r = THREE.MathUtils.lerp(TORNADO.BASE_RADIUS, TORNADO.TOP_RADIUS, t);
                    const thickness = TORNADO.THICKNESS * THREE.MathUtils.randFloat(0.8, 1.25);

                    const geo = new THREE.RingGeometry(
                        Math.max(0.01, r - thickness),
                        r,
                        TORNADO.SEGMENTS
                    );

                    const ring = new THREE.Mesh(geo, mat);
                    ring.rotation.x = Math.PI / 2;

                    ring.userData.baseY = y;
                    ring.position.y = y;

                    ring.userData.phase = Math.random() * Math.PI * 2;
                    // how far it drifts side to side; change middle number (lower = less movement, higher = more)
                    ring.userData.amp = THREE.MathUtils.lerp(0.05, 3.0, t);
                    ring.userData.freq = THREE.MathUtils.lerp(0.8, 2.0, t);

                    group.add(ring);
                }

                group.position.copy(pos);
                group.visible = false;
                scene.add(group);
                return group;
            }

            function animateTornado(t){
                for (const tor of tornadoes) {
                    const group = tor.group;
                    if (!group || !group.visible) continue;

                    group.position.copy(tor.pos);
                    group.rotation.set(0, 0, 0);

                    for (const ring of group.children){
                        const a = ring.userData.amp * (tor.move ?? 1.0);
                        const f = ring.userData.freq;
                        const p = ring.userData.phase;

                        ring.position.x = Math.sin(t * f + p) * a;
                        ring.position.z = Math.cos(t * f + p) * a * 0.6;
                        ring.position.y = ring.userData.baseY;
                    }
                }
            }

            function createStars(count = 4000) {
                const geo = new THREE.BufferGeometry();

                // scatter stars over big "shell" behind everything
                const positions = new Float32Array(count * 3);
                const sizes = new Float32Array(count);

                const rMin = 1200;
                const rMax = 2600;
                const MIN_Y_DIR = 0.15; // higher # = fewer near horizon (0.0 = horizon line, 1.0 = straight up)

                for (let i = 0; i < count; i++){
                    const theta = Math.random() * Math.PI * 2;

                    const yDir = THREE.MathUtils.lerp(MIN_Y_DIR, 1.0, Math.random());
                    const rXZ = Math.sqrt(1 - yDir * yDir);

                    const xDir = rXZ * Math.cos(theta);
                    const zDir = rXZ * Math.sin(theta);
                    const r = THREE.MathUtils.randFloat(rMin, rMax);

                    positions[i * 3 + 0] = xDir * r;
                    positions[i * 3 + 1] = yDir * r;
                    positions[i * 3 + 2] = zDir * r;
                }
                geo.setAttribute("position", new THREE.BufferAttribute(positions, 3));

                const mat = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 2.0,
                    sizeAttenuation: false,
                    transparent: true,
                    opacity: 0.95,
                    depthTest: false,
                    depthWrite: false,
                    fog: false,
                });

                const pts = new THREE.Points(geo, mat);
                pts.frustumCulled = false; // avoid accidental culling issues
                pts.renderOrder = -2000;
                pts.visible = false;
                return pts;
            }

            function makeShootingStar() {
                // A shooting star is just a 2-point line segment (tail -> head)
                const geo = new THREE.BufferGeometry();
                const positions = new Float32Array(2 * 3); // 2 vertices
                geo.setAttribute("position", new THREE.BufferAttribute(positions, 3));

                const mat = new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.0,
                    depthTest: false,
                    depthWrite: false,
                    fog: false,
                });

                const line = new THREE.Line(geo, mat);
                line.visible = false;
                line.frustumCulled = false;

                // runtime state
                line.userData.active = false;
                line.userData.life = 0;
                line.userData.age = 0;
                line.userData.speed = 0;
                line.userData.len = 0;
                line.userData.pos = new THREE.Vector3();
                line.userData.vel = new THREE.Vector3();

                return line;
            }

            function initShootingStars() {
                shootingStars = [];
                for (let i = 0; i < SHOOTING_STAR_COUNT; i++) {
                    const s = makeShootingStar();
                    shootingStars.push(s);
                    scene.add(s);
                }
            }

            function randomSkyPointAboveHorizon() {
                // similar to the star distribution: pick a direction with y >= SHOOTING.yDirMin
                const theta = Math.random() * Math.PI * 2;

                const yDir = THREE.MathUtils.lerp(SHOOTING.yDirMin, 1.0, Math.random());
                const rXZ = Math.sqrt(1 - yDir * yDir);

                const xDir = rXZ * Math.cos(theta);
                const zDir = rXZ * Math.sin(theta);

                const r = THREE.MathUtils.randFloat(SHOOTING.rMin, SHOOTING.rMax);

                return new THREE.Vector3(xDir * r, yDir * r, zDir * r);
            }

            function spawnShootingStar() {
                // Find an inactive star in the pool
                const s = shootingStars.find(ss => !ss.userData.active);
                if (!s) return;

                s.userData.active = true;
                s.userData.age = 0;
                s.userData.life = THREE.MathUtils.randFloat(SHOOTING.minLife, SHOOTING.maxLife);
                s.userData.speed = THREE.MathUtils.randFloat(SHOOTING.minSpeed, SHOOTING.maxSpeed);
                s.userData.len = THREE.MathUtils.randFloat(SHOOTING.minLen, SHOOTING.maxLen);

                // start point in the sky
                s.userData.pos.copy(randomSkyPointAboveHorizon());

                // choose a direction
                // (tweak these ranges for a different vibe)
                const dir = new THREE.Vector3(
                    THREE.MathUtils.randFloat(0.6, 1.0),
                    THREE.MathUtils.randFloat(-0.6, -0.2),
                    THREE.MathUtils.randFloat(-0.4, 0.4)
                ).normalize();

                s.userData.vel.copy(dir).multiplyScalar(s.userData.speed);

                s.visible = true;
            }

            function applyWeather(mode) {
                weatherMode = mode;

                let skyColor = CLEAR_SKY;
                let cloudColor = CLOUD_CLEAR;

                if (mode === WEATHER.RAIN) { skyColor = RAIN_SKY; cloudColor = CLOUD_RAIN; }
                else if (mode === WEATHER.SNOW) { skyColor = SNOW_SKY; cloudColor = CLOUD_SNOW; }
                else if (mode === WEATHER.TORNADO) { skyColor = TORNADO_SKY; cloudColor = CLOUD_TORNADO; }
                else if (mode === WEATHER.NIGHT) { skyColor = NIGHT_SKY; cloudColor = CLOUD_NIGHT; }

                const L = LIGHTS[mode];
                const nightOn = (mode === WEATHER.NIGHT);

                // set TARGETS only
                weatherTarget.sky.setHex(skyColor);
                weatherTarget.fog.setHex(skyColor);
                weatherTarget.cloud.setHex(cloudColor);

                weatherTarget.ambient = L.ambient;
                weatherTarget.sun = L.sun;
                weatherTarget.sunColor.setHex(nightOn ? MOON_LIGHT_COLOR : SUN_LIGHT_COLOR);

                weatherTarget.stars = nightOn ? 1 : 0;
                weatherTarget.sunVis = nightOn ? 0 : 1;
                weatherTarget.moonVis = nightOn ? 1 : 0;
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            function onKeyDown(event) {
                const k = event.key.toLowerCase();

                // rain with 'r'
                if (k === "r") {
                    precipMode = (precipMode === "rain") ? "none" : "rain";
                }
                // snow with 's'
                if (k === "s") {
                    precipMode = (precipMode === "snow") ? "none" : "snow";
                }
                // tornado with 't'
                if (k === "t"){
                    precipMode = (precipMode === "tornado") ? "none" : "tornado";
                }
                // night with 'n'
                if (k === "n"){
                    precipMode = (precipMode === "night") ? "none" : "night";
                }

                if (snowGroup) snowGroup.visible = (precipMode === "snow");
                if (rainGroup) rainGroup.visible = (precipMode === "rain");
                for (const t of tornadoes) t.group.visible = (precipMode === "tornado");

                if (precipMode === "rain") {
                    applyWeather(WEATHER.RAIN);
                } else if (precipMode === "snow") {
                    applyWeather(WEATHER.SNOW);
                } else if (precipMode === "tornado") {
                    applyWeather(WEATHER.TORNADO);
                } else if (precipMode === "night") {
                    applyWeather(WEATHER.NIGHT);
                } else {
                    applyWeather(WEATHER.CLEAR);
                }

            }

            // animation loop
            function animate() {
                requestAnimationFrame(animate);

                const t = clock.getElapsedTime(); // get time

                // frame delta time
                const delta = t - lastTime;
                lastTime = t;

                // sine wave for the wing flapping
                const flapOffset = Math.sin(t * FLAP_SPEED) * FLAP_AMPLITUDE;

                // ----- bird bobbing and flapping -----
                if (birdLoaded && birdGroup) {
                    const bob = Math.sin(t * BOB_SPEED) * BOB_AMPLITUDE;

                    // Target position around the bird’s base position
                    const targetX = baseBirdPos.x + mouseNDC.x * FOLLOW.maxX;
                    const targetZ = baseBirdPos.z + mouseNDC.y * FOLLOW.maxZ;
                    const targetY = baseBirdHeight + bob + mouseNDC.y * FOLLOW.maxY;

                    // Smooth follow (frame-rate independent)
                    const alpha = 1.0 - Math.exp(-FOLLOW.strength * delta);

                    birdGroup.position.x = THREE.MathUtils.lerp(birdGroup.position.x, targetX, alpha);
                    birdGroup.position.y = THREE.MathUtils.lerp(birdGroup.position.y, targetY, alpha);
                    birdGroup.position.z = THREE.MathUtils.lerp(birdGroup.position.z, targetZ, alpha);

                    // Small tilt so it feels like steering
                    const rollTarget  = -mouseNDC.x * FOLLOW.tiltRoll;
                    const pitchTarget =  mouseNDC.y * FOLLOW.tiltPitch;

                    birdGroup.rotation.z = THREE.MathUtils.lerp(birdGroup.rotation.z, rollTarget, alpha);
                    birdGroup.rotation.x = THREE.MathUtils.lerp(birdGroup.rotation.x, pitchTarget, alpha);
                }


                if (leftwing && rightwing) {
                    leftwing.rotation.x = baseLeftWingRoot + flapOffset;
                    rightwing.rotation.x = baseRightWingRoot - flapOffset;
                }

                // cloud animation
                if (clouds.length > 0) {
                    for (const cloud of clouds){

                        cloud.position.z += CLOUD_SPEED_Z * delta * cloud.userData.speed;

                        cloud.position.x += cloud.userData.dir * cloud.userData.drift * delta;

                        if (cloud.position.z > CLOUD_MAX_Z){
                            cloud.position.z = CLOUD_MIN_Z;
                            cloud.position.x = (Math.random() - 0.5) * CLOUD_SPREAD_X;
                            cloud.position.y = baseBirdHeight + (Math.random() - 0.5) * CLOUD_HEIGHT_VARIATION;
                        }
                    }
                }

                // animate snow
                if (precipMode === "snow" && snowGroup) {
                    const snowPoints = snowGroup.children[0];
                    const positions = snowPoints.geometry.attributes.position.array;

                    const RAIN_FALL_SPEED = 10.0;

                    // move each flake down by speed * delta
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i + 1] -= RAIN_FALL_SPEED * delta; // i + 1 is the y position

                        // if the snow falls below a certain height, respwn it at the top
                        if (positions[i + 1] < 0) {
                            positions[i + 1] = RAIN_HEIGHT;

                            // randomize x/z slightly when respawning
                            positions[i + 0] = (Math.random() - 0.5) * RAIN_AREA_XZ;
                            positions[i + 2] = (Math.random() - 0.5) * RAIN_AREA_XZ;
                        }
                    }
                    snowPoints.geometry.attributes.position.needsUpdate = true; // inform three.js of position changes
                }

                // animate rain
                if (precipMode === "rain" && rainGroup){
                    const lines = rainGroup.children[0];
                    const posAttr = lines.geometry.attributes.position;
                    const positions = posAttr.array;

                    const speeds = rainGroup.userData.speeds;
                    const lengths = rainGroup.userData.lengths;

                    // wind
                    const windX = 1.5;

                    for (let i = 0; i < RAIN_COUNT; i++){
                        const base = i * 6;

                        positions[base + 1] -= speeds[i] * delta;

                        // apply slight sideways wind to both endpoints
                        positions[base + 0] += windX * delta;
                        positions[base + 3] += windX * delta;

                        // endpoint follows
                        positions[base + 4] = positions[base + 1] - lengths[i];

                        // respawn if below a certain point
                        if (positions[base + 1] < 0) {
                            const x = (Math.random() - 0.5) * RAIN_AREA_XZ;
                            const y = RAIN_HEIGHT;
                            const z = (Math.random() - 0.5) * RAIN_AREA_XZ;

                            positions[base + 0] = x;
                            positions[base + 1] = y;
                            positions[base + 2] = z;

                            positions[base + 3] = x;
                            positions[base + 4] = y - lengths[i];
                            positions[base + 5] = z;
                        }
                    }
                    posAttr.needsUpdate = true;
                }

                // animate tornado
                animateTornado(t);
                // sun and moon
                for (const obj of [window.__sun, window.__moon]) {
                    if (!obj || !obj.userData.billboard) continue;
                    for (const p of obj.userData.billboard) {
                        p.quaternion.copy(camera.quaternion);
                    }
                }

                // twinkle the stars
                if (stars && stars.visible) {
                    stars.material.opacity = 0.75 + 0.20 * Math.sin(t * 0.8);
                }
                // shooting stars (night only)
                if (precipMode === "night") {
                    // probabilistic spawn: chance per second
                    if (Math.random() < SHOOTING.spawnChancePerSec * delta) {
                        spawnShootingStar();
                    }

                    for (const s of shootingStars) {
                        if (!s.userData.active) continue;

                        s.userData.age += delta;

                        // fade in/out over lifetime
                        const u = s.userData.age / s.userData.life; // 0..1
                        const fadeIn = Math.min(1, u / 0.15);
                        const fadeOut = Math.min(1, (1 - u) / 0.25);
                        s.material.opacity = 0.9 * Math.min(fadeIn, fadeOut);

                        // move head along velocity
                        s.userData.pos.addScaledVector(s.userData.vel, delta);

                        // update line geometry: tail behind head
                        const head = s.userData.pos;
                        const tail = head.clone().addScaledVector(s.userData.vel, -s.userData.len / s.userData.speed);

                        const posAttr = s.geometry.attributes.position;
                        const arr = posAttr.array;

                        // tail
                        arr[0] = tail.x; arr[1] = tail.y; arr[2] = tail.z;
                        // head
                        arr[3] = head.x; arr[4] = head.y; arr[5] = head.z;

                        posAttr.needsUpdate = true;

                        // end of life
                        if (s.userData.age >= s.userData.life) {
                        s.userData.active = false;
                        s.material.opacity = 0.0;
                        s.visible = false;
                        }
                    }
                }

                // fade weather each frame
                const a = 1.0 - Math.exp(-WEATHER_FADE_SPEED * delta);

                // colors
                weatherNow.sky.lerp(weatherTarget.sky, a);
                weatherNow.fog.lerp(weatherTarget.fog, a);
                weatherNow.cloud.lerp(weatherTarget.cloud, a);

                // intensities
                weatherNow.ambient = THREE.MathUtils.lerp(weatherNow.ambient, weatherTarget.ambient, a);
                weatherNow.sun = THREE.MathUtils.lerp(weatherNow.sun, weatherTarget.sun, a);

                // sun/moon color + visibility fades
                weatherNow.sunColor.lerp(weatherTarget.sunColor, a);
                weatherNow.stars = THREE.MathUtils.lerp(weatherNow.stars, weatherTarget.stars, a);
                weatherNow.sunVis = THREE.MathUtils.lerp(weatherNow.sunVis, weatherTarget.sunVis, a);
                weatherNow.moonVis = THREE.MathUtils.lerp(weatherNow.moonVis, weatherTarget.moonVis, a);

                // APPLY to renderer/scene
                renderer.setClearColor(weatherNow.sky, 1);
                scene.fog.color.copy(weatherNow.fog);

                ambientLight.intensity = weatherNow.ambient;
                sunLight.intensity = weatherNow.sun;
                sunLight.color.copy(weatherNow.sunColor);

                // cloud recolor
                for (const m of cloudMats) m.color.copy(weatherNow.cloud);

                // stars fade (instead of hard visible on/off)
                if (stars) {
                    stars.visible = weatherNow.stars > 0.01;
                    stars.material.opacity = (0.6 + 0.2 * Math.sin(t * 0.8)) * weatherNow.stars;
                }

                // sun/moon fade (fade their materials)
                if (window.__sun) {
                    window.__sun.visible = weatherNow.sunVis > 0.01;
                    window.__sun.traverse(o => { if (o.material && "opacity" in o.material) { o.material.transparent = true; o.material.opacity = weatherNow.sunVis; } });
                }
                if (window.__moon) {
                    window.__moon.visible = weatherNow.moonVis > 0.01;
                    window.__moon.traverse(o => { if (o.material && "opacity" in o.material) { o.material.transparent = true; o.material.opacity = weatherNow.moonVis; } });
                }

                if (controls) controls.update();
                renderer.render(scene, camera);
            }
        </script>
    </body>
</html>