<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Feather</title>

        <style>
            html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            }

            #c {
                width: 100%;
                height: 100%;
                display: block;
            }
        </style>
        <!-- NEW: Import map so addons can resolve `import ... from 'three'` -->
        <script type="importmap">
        {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
        }
        </script>

    </head>
    <body>
        <canvas id="c"></canvas>

        <script type="module">
            // three.js imports
            import * as THREE from "three";
            import { OrbitControls } from "three/addons/controls/OrbitControls.js";
            import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";


            // basic setup
            let renderer, scene, camera, controls;
            let birdGroup, birdBody;
            let modelRoot = null;
            let leftwing = null;
            let rightwing = null;
            let baseLeftWingRoot = 0;
            let baseRightWingRoot = 0;
            let birdLoaded = false;

            // audio variables
            let audioListener, backgroundMusic; // audioListener are is the "ears" in the scene
            let musicLoaded = false;
            let musicVolume = 0.4;
            let musicMuted = false;

            // bird animation parameters
            const clock = new THREE.Clock(); // clock to give elapsed time in seconds
            const FLAP_SPEED = 4.0;
            const FLAP_AMPLITUDE = Math.PI / 6; // max wing rotation angle
            const BOB_SPEED = 1.5; // bobbing speed for bird
            const BOB_AMPLITUDE = 0.6; // bobbing height

            

            // store the "rest" position of the bird to animate around it
            let baseLeftWingAngle = 0;
            let baseRightWingAngle = 0;
            let baseBirdHeight = 0;

            // cloud variables
            let clouds = [];
            const NUM_CLOUDS = 500;
            
            const cloudMats = [];

            let CLOUD_FAR_Z = -180;
            let CLOUD_NEAR_Z = 0;

            const CLOUD_HEIGHT = 13.0; // typical cloud height
            const CLOUD_HEIGHT_VARIATION = 50.0;
            const CLOUD_SPREAD_X = 80; // how far clouds can appear to the left and right
            const CLOUD_SPEED_Z = 18.0;
            let lastTime = 0; // for computing time diff between frames 

            // rain variables
            let precipMode = "none"; // none || snow || rain
            let snowGroup = null;
            let rainGroup = null;
            const RAIN_COUNT = 500;
            const RAIN_AREA_XZ = 40; // how wide/deep the rain area is
            const RAIN_HEIGHT = 12; // how high above the scene raindrops start
            let isRaining = false;

            // tornado variables
            let tornadoGroup = null;
            const TORNADO = {
                LAYERS: 300, // # of circular layers
                HEIGHT: 26,
                BASE_RADIUS: 1.0,
                TOP_RADIUS: 7.0,
                THICKNESS: 0.22,
                OPACITY: 0.18,
                SEGMENTS: 32,
                POS: new THREE.Vector3(28, 0, -25)
            };

            const WEATHER = { CLEAR: "clear", RAIN: "rain", SNOW: "snow", TORNADO: "tornado" };
            let weatherMode = WEATHER.CLEAR;

            let ambientLight, sunLight;

            const CLEAR_SKY = 0x87ceeb;
            const RAIN_SKY = 0x5f7f95;
            const SNOW_SKY = 0x7fb6d4;
            const TORNADO_SKY = 0x808080;
            const CLOUD_CLEAR = 0xffffff;
            const CLOUD_SNOW = 0xd6d6d6;
            const CLOUD_RAIN = 0x6a6a6a;
            const CLOUD_TORNADO = 0x808080;
            const CLOUD_OPACITY = 0.7;

            const LIGHTS = {
                clear: { ambient: 0.30, sun: 1.00 },
                snow: { ambient: 0.22, sun: 0.80 },
                rain: { ambient: 0.15, sun: 0.65 },
                tornado: { ambient: 0.18, sun: 0.55 },
            };



            init();
            animate();

            // keyboard control for bakcground music
            window.addEventListener('keydown', (event) => {
                if (!musicLoaded || !backgroundMusic) return;
                // toggle with m key
                if (event.key === 'm' || event.key === 'M') {
                    // if the music is not playing and it is not muted, then begin playing the music
                    if (!backgroundMusic.isPlaying && !musicMuted) {
                        backgroundMusic.play();
                        return;
                    }
                    // otherwise, mute the music
                    musicMuted = !musicMuted;
                    if (musicMuted) {
                        backgroundMusic.setVolume(0);
                    } else {
                        backgroundMusic.setVolume(musicVolume);
                        // if for some reason the music stopped, restart
                        if (!backgroundMusic.isPlaying) {
                            backgroundMusic.play();
                        }
                    }
                }
            });

            function frameObject(object3D, camera, controls, offset = 1.25) {
                const box = new THREE.Box3().setFromObject(object3D);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());

                // How far the camera needs to be to fit the object
                const maxDim = Math.max(size.x, size.y, size.z);
                const fov = THREE.MathUtils.degToRad(camera.fov);
                let cameraZ = Math.abs((maxDim / 2) / Math.tan(fov / 2)) * offset;

                // Put camera in front of the object (positive Z direction)
                camera.position.set(center.x, center.y, center.z + cameraZ);

                // Set near/far so it doesn't clip
                camera.near = cameraZ / 100;
                camera.far = cameraZ * 100;
                camera.updateProjectionMatrix();

                // Center the controls on the object
                controls.target.copy(center);
                controls.update();

                // Make sure the camera is actually looking at the center
                camera.lookAt(center);
            }


            function init() {
                const canvas = document.getElementById("c");

                // renderer
                renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true});
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(0x87ceeb, 1); // sky blue

                // scene
                scene = new THREE.Scene();

                // adding fog to the scene for fading distant objects
                scene.fog = new THREE.Fog(0x87ceeb, 10, 60);

                // camera
                const fov = 60;
                const aspect = window.innerWidth / window.innerHeight;
                const near = 0.1;
                const far = 1000;
                camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
                camera.position.set(0, 2, 6);
                scene.add(camera);

                // =============== audio setup ===============
                audioListener = new THREE.AudioListener();
                camera.add(audioListener);

                backgroundMusic = new THREE.Audio(audioListener); // global audio object for background music
                const audioLoader = new THREE.AudioLoader();
                audioLoader.load(
                    'audio/Nujabes-Feather.mp3',
                    (buffer) => {
                        backgroundMusic.setBuffer(buffer); // assign audio data
                        backgroundMusic.setLoop(true);
                        backgroundMusic.setVolume(musicVolume);
                        musicLoaded = true;
                    },
                    undefined,
                    (error) => {
                        console.error("Error loading background music:", error);
                    }
                );
                // ==========================================

                // orbit controls (for debugging)
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.target.set(0, 2, 0);
                controls.update();

                // lights
                ambientLight = new THREE.AmbientLight(0xffffff, LIGHTS.clear.ambient);
                scene.add(ambientLight);

                sunLight = new THREE.DirectionalLight(0xfff2cc, LIGHTS.clear.sun);
                sunLight.position.set(5, 10, 5);
                scene.add(sunLight);

                applyWeather(WEATHER.CLEAR);

                // sun disc
                const sunGeo = new THREE.SphereGeometry(1.5, 32, 16);
                const sunMat = new THREE.MeshStandardMaterial({
                    color: 0xfff7d1,
                    emissive: 0xfff7d1, // glow
                    emissiveIntensity: 1.0 // brightness of glow
                })
                const sunDisc = new THREE.Mesh(sunGeo, sunMat);
                // position of the sun; far away in background
                sunDisc.position.set(-15, 20, -30);
                scene.add(sunDisc);

                //=============== create clouds ===============
                // build clouds at random positions in the sky
                for (let i = 0; i < NUM_CLOUDS; i++){
                    const cloud = createCloud(); // helper function
                    scene.add(cloud);
                    clouds.push(cloud);
                }
                //=============================================

                //=============== create snow ===============
                createSnow();
                if (snowGroup) {
                    snowGroup.visible = false; // start with no snow
                }
                //=============================================
                //=============== create rain =================
                createRain();
                //=============================================
                //=============== create tornado =================
                createTornado();
                //=============================================

                //=============== bird geometry ===============
                birdGroup = new THREE.Group();
                scene.add(birdGroup);

                const loader = new GLTFLoader();
                loader.load(
                "Seagull.glb", 
                (gltf) => {
                    const model = gltf.scene;
                    birdGroup.add(model);

                    modelRoot = model;
                    birdLoaded = true;

                    // Find the wings
                    leftwing = model.getObjectByName("Leftwing");
                    rightwing = model.getObjectByName("Rightwing");

                    console.log("Leftwing:", leftwing);
                    console.log("Rightwing:", rightwing);


                    const box = new THREE.Box3().setFromObject(model);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    model.position.sub(center);
                    const scale = 2.0 / Math.max(size.x, size.y, size.z);
                    model.scale.setScalar(scale);
                    model.rotation.y += 1.5;

                    // place bird where your scene expects it
                    const BIRD_HEIGHT = 13.0;
                    birdGroup.position.set(0, BIRD_HEIGHT, 0);
                    baseBirdHeight = birdGroup.position.y;

                    frameObject(birdGroup, camera, controls, 3.0);

                    CLOUD_NEAR_Z = camera.position.z + 10;
                    CLOUD_FAR_Z = camera.position.z - 220;

                    for (const c of clouds) respawnCloud(c);

                    console.log("GLB loaded:", { size, center, scale });
                },
                undefined,
                (err) => console.error("GLB load error:", err)
                );

                scene.add(birdGroup);

                //=============================================

                // handle resize
                window.addEventListener('resize', onWindowResize);

                // listen for keypress to toggle rain
                window.addEventListener('keydown', onKeyDown);
            }

            // function to create clouds
            function createCloud() {
                const cloud = new THREE.Object3D(); // parent object for puff meshes

                // random # of puffs per cloud ( 3 - 5 )
                const numPuffs = 3 + Math.floor(Math.random() * 3);

                for (let i = 0; i < numPuffs; i++) {
                    // slight varied radius fo each puff
                    const radius = THREE.MathUtils.randFloat(0.3, 0.8);

                    const geo = new THREE.SphereGeometry(radius, 16, 12);
                    const mat = new THREE.MeshStandardMaterial({
                        color: CLOUD_CLEAR,
                        roughness: 0.9,
                        metalness: 0.0,
                        transparent: true,
                        opacity: CLOUD_OPACITY
                    });
                    cloudMats.push(mat);
                    const puff = new THREE.Mesh(geo, mat);

                    // random offsets so the puffs aren't symmetric 
                    puff.position.set(
                        (Math.random() - 0.5) * 1.6, // left/right 
                        (Math.random() - 0.5) * 0.4, // up/down 
                        (Math.random() - 0.5) * 0.6 // front/back 
                    );
                    cloud.add(puff);
                }

                // position the entire cloud somewhere in the sky
                cloud.position.set(
                    (Math.random() - 0.5) * CLOUD_SPREAD_X, // x spread
                    CLOUD_HEIGHT + (Math.random() - 0.5) * CLOUD_HEIGHT_VARIATION, // slight y variation
                    THREE.MathUtils.randFloat(CLOUD_FAR_Z, CLOUD_NEAR_Z) // random depth
                );

                cloud.scale.set(
                    1.5 + Math.random() * 2.0, // width
                    1.0 + Math.random() * 0.5, // height
                    1.0 + Math.random() * 0.3 // depth
                ); // slightly stretch cloud to get more of a cloud-effect

                cloud.userData.speed = THREE.MathUtils.randFloat(0.5, 2.0); // each cloud moves at diff speeds
                cloud.userData.dir = Math.random() < 0.5 ? -1 : 1; // left or right

                return cloud;
            }

            function respawnCloud(cloud) {
                cloud.position.x = (Math.random() - 0.5) * CLOUD_SPREAD_X;
                cloud.position.y = baseBirdHeight + (Math.random() - 0.5) * CLOUD_HEIGHT_VARIATION;
                cloud.position.z = THREE.MathUtils.randFloat(CLOUD_FAR_Z, CLOUD_FAR_Z + 120);

                cloud.scale.set(
                    1.5 + Math.random() * 2.0,
                    1.0 + Math.random() * 0.5,
                    1.0 + Math.random() * 0.3
                );

                cloud.userData.speed = THREE.MathUtils.randFloat(0.5, 2.0);
                cloud.userData.dir = Math.random() < 0.5 ? -1 : 1;
                cloud.userData.drift = THREE.MathUtils.randFloat(0.2, 1.2); // NEW

            }


            // function for the snow
            function createSnow() {
                snowGroup = new THREE.Group();
                // buffer geometry to hold positions of all raindrops
                const positions = new Float32Array(RAIN_COUNT * 3);

                for (let i = 0; i < RAIN_COUNT; i++) {
                    const idx = i * 3;
                    // random x/z within a square area around origin
                    positions[idx + 0] = (Math.random() - 0.5) * RAIN_AREA_XZ; // x
                    positions[idx + 1] = Math.random() * RAIN_HEIGHT + 2; // y
                    positions[idx + 2] = (Math.random() - 0.5) * RAIN_AREA_XZ; // z
                }

                const snowGeo = new THREE.BufferGeometry();
                snowGeo.setAttribute(
                    'position',
                    new THREE.BufferAttribute(positions, 3)
                );

                const snowMat = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 0.06,     // screen space size of each snowflake
                    transparent: true,
                    opacity: 0.9
                })

                const snowPoints = new THREE.Points(snowGeo, snowMat);
                snowGroup.add(snowPoints);
                scene.add(snowGroup);
            }

            function createRain(){
                rainGroup = new THREE.Group();

                // each raindrop has two vertices, a start and end point
                const rainPositions = new Float32Array(RAIN_COUNT * 2 * 3);
                const speeds = new Float32Array(RAIN_COUNT);
                const lengths = new Float32Array(RAIN_COUNT);

                for (let i = 0; i < RAIN_COUNT; i++){
                    const x = (Math.random() - 0.5) * RAIN_AREA_XZ;
                    const y = Math.random() * RAIN_HEIGHT + 2;
                    const z = (Math.random() - 0.5) * RAIN_AREA_XZ;

                    speeds[i] = THREE.MathUtils.randFloat(18, 35); // faster than the snow
                    lengths[i] = THREE.MathUtils.randFloat(0.6, 1.6); // longer streak to more clearly identify as rain

                    // starting vertex
                    rainPositions[i * 6 + 0] = x;
                    rainPositions[i * 6 + 1] = y;
                    rainPositions[i * 6 + 2] = z;

                    // end vertex
                    rainPositions[i * 6 + 3] = x;
                    rainPositions[i * 6 + 4] = y;
                    rainPositions[i * 6 + 5] = z;
                }

                const rainGeo = new THREE.BufferGeometry();
                rainGeo.setAttribute("position", new THREE.BufferAttribute(rainPositions, 3));

                const rainMat = new THREE.LineBasicMaterial({
                    color: 0xddeeff,
                    transparent: true,
                    opacity: 0.65
                });

                const lines = new THREE.LineSegments(rainGeo, rainMat);
                rainGroup.add(lines);

                rainGroup.userData.speeds = speeds;
                rainGroup.userData.lengths = lengths;
                rainGroup.visible = false;
                scene.add(rainGroup);
            }

            function createTornado() {
                tornadoGroup = new THREE.Group();

                const layers = TORNADO.LAYERS;
                const h = TORNADO.HEIGHT;

                // shared material
                const mat = new THREE.MeshBasicMaterial({
                    color: 0xe7e7e7,
                    transparent: true,
                    opacity: TORNADO.OPACITY,
                    depthWrite: false, // helps translucent stacking look nicer
                });

                for (let i = 0; i < layers; i++) {
                    const t = i / (layers - 1);
                    const y = t * h;

                    // the radius grows as you go higher
                    const r = THREE.MathUtils.lerp(TORNADO.BASE_RADIUS, TORNADO.TOP_RADIUS, t);
                    const thickness = TORNADO.THICKNESS * THREE.MathUtils.randFloat(0.8, 1.25);

                    const geo = new THREE.RingGeometry(
                        Math.max(0.01, r - thickness),
                        r,
                        TORNADO.SEGMENTS
                    );

                    const ring = new THREE.Mesh(geo, mat);
                    ring.rotation.x = Math.PI / 2;
                    ring.position.y = y;

                    ring.userData.phase = Math.random() * Math.PI * 2;
                    // how far it drifts side to side; change middle number (lower = less movement, higher = more)
                    ring.userData.amp = THREE.MathUtils.lerp(0.05, 3.0, t);
                    ring.userData.freq = THREE.MathUtils.lerp(0.8, 2.0, t);

                    // store per-layer motion
                    ring.userData.spin = THREE.MathUtils.randFloat(1.5, 4.5) * (0.6 + t); // faster near top
                    ring.userData.wobble = THREE.MathUtils.randFloat(0.15, 0.65) * (0.4 + t);

                    tornadoGroup.add(ring);
                }

                tornadoGroup.position.copy(TORNADO.POS);
                tornadoGroup.rotation.set(0, 0, 0);
                tornadoGroup.visible = false;
                scene.add(tornadoGroup);
            }

            function animateTornado(t){
                if (!tornadoGroup || !tornadoGroup.visible) return;

                tornadoGroup.position.copy(TORNADO.POS);
                tornadoGroup.rotation.set(0, 0, 0);

                for (const ring of tornadoGroup.children){
                    const a = ring.userData.amp;
                    const f = ring.userData.freq;
                    const p = ring.userData.phase;

                    ring.position.x = Math.sin(t *  f + p) * a;
                    ring.position.z = Math.cos(t * f + p) * a * 0.6;
                }
            }

            function applyWeather(mode){
                weatherMode = mode;

                // pick colors for the clouds and sky
                let skyColor = CLEAR_SKY;
                let cloudColor = CLOUD_CLEAR;

                if (mode === WEATHER.RAIN) {
                    skyColor = RAIN_SKY;
                    cloudColor = CLOUD_RAIN;
                } else if (mode === WEATHER.SNOW) {
                    skyColor = SNOW_SKY;
                    cloudColor = CLOUD_SNOW;
                } else if (mode === WEATHER.TORNADO){
                    skyColor = TORNADO_SKY;
                    cloudColor = CLOUD_TORNADO;
                }

                // sky + fog match
                renderer.setClearColor(skyColor, 1);
                scene.fog.color.setHex(skyColor);

                // lighting
                const L = LIGHTS[mode];
                ambientLight.intensity = L.ambient;
                sunLight.intensity = L.sun;

                // clouds recolor
                for (const m of cloudMats){
                    m.color.setHex(cloudColor);
                }
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            function onKeyDown(event) {
                const k = event.key.toLowerCase();

                // rain with 'r'
                if (k === "r") {
                    precipMode = (precipMode === "rain") ? "none" : "rain";
                }
                // snow with 's'
                if (k === "s") {
                    precipMode = (precipMode === "snow") ? "none" : "snow";
                }
                // tornado with 't'
                if (k === "t"){
                    precipMode = (precipMode === "tornado") ? "none" : "tornado";
                }

                if (snowGroup) snowGroup.visible = (precipMode === "snow");
                if (rainGroup) rainGroup.visible = (precipMode === "rain");
                if (tornadoGroup) tornadoGroup.visible = (precipMode === "tornado");

                if (precipMode === "rain") {
                    applyWeather(WEATHER.RAIN);
                } else if (precipMode === "snow") {
                    applyWeather(WEATHER.SNOW);
                } else if (precipMode === "tornado") {
                    applyWeather(WEATHER.TORNADO);
                } else {
                    applyWeather(WEATHER.CLEAR);
                }

            }

            // animation loop
            function animate() {
                requestAnimationFrame(animate);

                const t = clock.getElapsedTime(); // get time

                // frame delta time
                const delta = t - lastTime;
                lastTime = t;

                // sine wave for the wing flapping
                const flapOffset = Math.sin(t * FLAP_SPEED) * FLAP_AMPLITUDE;

                // ----- bird bobbing and flapping -----
                if (birdLoaded && birdGroup) {
                    const bob = Math.sin(t * BOB_SPEED) * BOB_AMPLITUDE;
                    birdGroup.position.y = baseBirdHeight + bob;

                }

                if (leftwing && rightwing) {
                    leftwing.rotation.x = baseLeftWingRoot + flapOffset;
                    rightwing.rotation.x = baseRightWingRoot - flapOffset;
                }

                // cloud animation
                if (clouds.length > 0) {
                    for (const cloud of clouds){

                        cloud.position.z += CLOUD_SPEED_Z * delta * cloud.userData.speed;

                        cloud.position.x += cloud.userData.dir * cloud.userData.drift * delta;

                        if (cloud.position.z > CLOUD_NEAR_Z){
                            respawnCloud(cloud);
                        }
                    }
                }

                // animate snow
                if (precipMode === "snow" && snowGroup) {
                    const snowPoints = snowGroup.children[0];
                    const positions = snowPoints.geometry.attributes.position.array;

                    const RAIN_FALL_SPEED = 10.0;

                    // move each flake down by speed * delta
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i + 1] -= RAIN_FALL_SPEED * delta; // i + 1 is the y position

                        // if the snow falls below a certain height, respwn it at the top
                        if (positions[i + 1] < 0) {
                            positions[i + 1] = RAIN_HEIGHT;

                            // randomize x/z slightly when respawning
                            positions[i + 0] = (Math.random() - 0.5) * RAIN_AREA_XZ;
                            positions[i + 2] = (Math.random() - 0.5) * RAIN_AREA_XZ;
                        }
                    }
                    snowPoints.geometry.attributes.position.needsUpdate = true; // inform three.js of position changes
                }

                // animate rain
                if (precipMode === "rain" && rainGroup){
                    const lines = rainGroup.children[0];
                    const posAttr = lines.geometry.attributes.position;
                    const positions = posAttr.array;

                    const speeds = rainGroup.userData.speeds;
                    const lengths = rainGroup.userData.lengths;

                    // wind
                    const windX = 1.5;

                    for (let i = 0; i < RAIN_COUNT; i++){
                        const base = i * 6;

                        positions[base + 1] -= speeds[i] * delta;

                        // apply slight sideways wind to both endpoints
                        positions[base + 0] += windX * delta;
                        positions[base + 3] += windX * delta;

                        // endpoint follows
                        positions[base + 4] = positions[base + 1] - lengths[i];

                        // respawn if below a certain point
                        if (positions[base + 1] < 0) {
                            const x = (Math.random() - 0.5) * RAIN_AREA_XZ;
                            const y = RAIN_HEIGHT;
                            const z = (Math.random() - 0.5) * RAIN_AREA_XZ;

                            positions[base + 0] = x;
                            positions[base + 1] = y;
                            positions[base + 2] = z;

                            positions[base + 3] = x;
                            positions[base + 4] = y - lengths[i];
                            positions[base + 5] = z;
                        }
                    }
                    posAttr.needsUpdate = true;
                }

                // animate tornado
                animateTornado(t);

                if (controls) controls.update();
                renderer.render(scene, camera);
            }
        </script>
    </body>
</html>