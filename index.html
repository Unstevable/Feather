<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Feather</title>

        <style>
            html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            }

            #c {
                width: 100%;
                height: 100%;
                display: block;
            }
        </style>
        <!-- NEW: Import map so addons can resolve `import ... from 'three'` -->
        <script type="importmap">
        {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
        }
        </script>

    </head>
    <body>
        <canvas id="c"></canvas>

        <script type="module">
            // three.js imports
            import * as THREE from "three";
            import { OrbitControls } from "three/addons/controls/OrbitControls.js";
            import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";


            // basic setup
            let renderer, scene, camera, controls;
            let birdGroup, birdBody;
            let modelRoot = null;
            let leftwing = null;
            let rightwing = null;
            let baseLeftWingRoot = 0;
            let baseRightWingRoot = 0;
            let birdLoaded = false;

            // audio variables
            let audioListener, backgroundMusic; // audioListener are is the "ears" in the scene
            let musicLoaded = false;
            let musicVolume = 0.4;
            let musicMuted = false;

            // bird animation parameters
            const clock = new THREE.Clock(); // clock to give elapsed time in seconds
            const FLAP_SPEED = 4.0;
            const FLAP_AMPLITUDE = Math.PI / 6; // max wing rotation angle
            const BOB_SPEED = 1.5; // bobbing speed for bird
            const BOB_AMPLITUDE = 0.6; // bobbing height

            

            // store the "rest" position of the bird to animate around it
            let baseLeftWingAngle = 0;
            let baseRightWingAngle = 0;
            let baseBirdHeight = 0;

            // cloud variables
            let clouds = [];
            const NUM_CLOUDS = 40;
            const CLOUD_MIN_Z = -10; // cloud closest z-range
            const CLOUD_MAX_Z = -40; // cloud farthest z-range
            const CLOUD_HEIGHT = 2.5; // typical cloud height
            const CLOUD_SPREAD_X = 80; // how far clouds can appear to the left and right
            const CLOUD_SPEED = 2.0;
            let lastTime = 0; // for computing time diff between frames 

            // rain variables
            let rainGroup = null; // group to hold rain drops
            const RAIN_COUNT = 500;
            const RAIN_AREA_XZ = 40; // how wide/deep the rain area is
            const RAIN_HEIGHT = 12; // how high above the scene raindrops start
            let isRaining = false;

            init();
            animate();

            // keyboard control for bakcground music
            window.addEventListener('keydown', (event) => {
                if (!musicLoaded || !backgroundMusic) return;
                // toggle with m key
                if (event.key === 'm' || event.key === 'M') {
                    // if the music is not playing and it is not muted, then begin playing the music
                    if (!backgroundMusic.isPlaying && !musicMuted) {
                        backgroundMusic.play();
                        return;
                    }
                    // otherwise, mute the music
                    musicMuted = !musicMuted;
                    if (musicMuted) {
                        backgroundMusic.setVolume(0);
                    } else {
                        backgroundMusic.setVolume(musicVolume);
                        // if for some reason the music stopped, restart
                        if (!backgroundMusic.isPlaying) {
                            backgroundMusic.play();
                        }
                    }
                }
            });

            function frameObject(object3D, camera, controls, offset = 1.25) {
                const box = new THREE.Box3().setFromObject(object3D);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());

                // How far the camera needs to be to fit the object
                const maxDim = Math.max(size.x, size.y, size.z);
                const fov = THREE.MathUtils.degToRad(camera.fov);
                let cameraZ = Math.abs((maxDim / 2) / Math.tan(fov / 2)) * offset;

                // Put camera in front of the object (positive Z direction)
                camera.position.set(center.x, center.y, center.z + cameraZ);

                // Set near/far so it doesn't clip
                camera.near = cameraZ / 100;
                camera.far = cameraZ * 100;
                camera.updateProjectionMatrix();

                // Center the controls on the object
                controls.target.copy(center);
                controls.update();

                // Make sure the camera is actually looking at the center
                camera.lookAt(center);
            }


            function init() {
                const canvas = document.getElementById("c");

                // renderer
                renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true});
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(0x87ceeb, 1); // sky blue

                // scene
                scene = new THREE.Scene();

                // adding fog to the scene for fading distant objects
                scene.fog = new THREE.Fog(0x87ceeb, 10, 60);

                // camera
                const fov = 60;
                const aspect = window.innerWidth / window.innerHeight;
                const near = 0.1;
                const far = 1000;
                camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
                camera.position.set(0, 2, 6);
                scene.add(camera);

                // =============== audio setup ===============
                audioListener = new THREE.AudioListener();
                camera.add(audioListener);

                backgroundMusic = new THREE.Audio(audioListener); // global audio object for background music
                const audioLoader = new THREE.AudioLoader();
                audioLoader.load(
                    'audio/Nujabes-Feather.mp3',
                    (buffer) => {
                        backgroundMusic.setBuffer(buffer); // assign audio data
                        backgroundMusic.setLoop(true);
                        backgroundMusic.setVolume(musicVolume);
                        musicLoaded = true;
                    },
                    undefined,
                    (error) => {
                        console.error("Error loading background music:", error);
                    }
                );
                // ==========================================

                // orbit controls (for debugging)
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.target.set(0, 2, 0);
                controls.update();

                // lights
                const ambient = new THREE.AmbientLight(0xffffff, 0.3);
                scene.add(ambient);

                // directional light as the sun
                const sunlight = new THREE.DirectionalLight(0xfff2cc, 1.0);
                sunlight.position.set(5, 10, 5);
                scene.add(sunlight);

                // sun disc
                const sunGeo = new THREE.SphereGeometry(1.5, 32, 16);
                const sunMat = new THREE.MeshStandardMaterial({
                    color: 0xfff7d1,
                    emissive: 0xfff7d1, // glow
                    emissiveIntensity: 1.0 // brightness of glow
                })
                const sunDisc = new THREE.Mesh(sunGeo, sunMat);
                // position of the sun; far away in background
                sunDisc.position.set(-15, 20, -30);
                scene.add(sunDisc);

                //=============== create clouds ===============
                // build clouds at random positions in the sky
                for (let i = 0; i < NUM_CLOUDS; i++){
                    const cloud = createCloud(); // helper function
                    scene.add(cloud);
                    clouds.push(cloud);
                }
                //=============================================

                //=============== create rain ===============
                createRain();
                if (rainGroup) {
                    rainGroup.visible = false; // start with no rain
                }
                //=============================================

                //=============== bird geometry ===============
                birdGroup = new THREE.Group();
                scene.add(birdGroup);

                const loader = new GLTFLoader();
                loader.load(
                "Flying_seagull.glb", 
                (gltf) => {
                    const model = gltf.scene;
                    birdGroup.add(model);

                    modelRoot = model;
                    birdLoaded = true;

                    // try to find wings by name
                    modelRoot.traverse((obj) => {
                        const n = (obj.name || "").toLowerCase();

                        if (!leftwing && n.includes("wing") && n.includes("left")) leftwing = obj;
                        if (!rightwing && n.includes("wing") && n.includes("right")) rightwing = obj;
                    });

                    // if that fails, dump node names to pick the correct ones
                    if (!leftwing || !rightwing){
                        console.log("Wing search failed.  Node names in model: ");
                        modelRoot.traverse((o) => { if (o.name) console.log(o.name); });
                    } else {
                        baseLeftWingRoot = leftwing.rotation.x;
                        baseRightWingRoot = rightwing.rotation.x;

                        console.log("Wings found: ", leftwing.name, rightwing.name);
                    }

                    const box = new THREE.Box3().setFromObject(model);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    model.position.sub(center);
                    const scale = 2.0 / Math.max(size.x, size.y, size.z);
                    model.scale.setScalar(scale);

                    // place bird where your scene expects it
                    const BIRD_HEIGHT = 13.0;
                    birdGroup.position.set(0, BIRD_HEIGHT, 0);
                    baseBirdHeight = birdGroup.position.y;

                    frameObject(birdGroup, camera, controls, 3.0);

                    console.log("GLB loaded:", { size, center, scale });
                },
                undefined,
                (err) => console.error("GLB load error:", err)
                );

                scene.add(birdGroup);

                //=============================================

                // handle resize
                window.addEventListener('resize', onWindowResize);

                // listen for keypress to toggle rain
                window.addEventListener('keydown', onKeyDown);
            }

            // function to create clouds
            function createCloud() {
                const cloud = new THREE.Object3D(); // parent object for puff meshes

                // random # of puffs per cloud ( 3 - 5 )
                const numPuffs = 3 + Math.floor(Math.random() * 3);

                for (let i = 0; i < numPuffs; i++) {
                    // slight varied radius fo each puff
                    const radius = THREE.MathUtils.randFloat(0.3, 0.8);

                    const geo = new THREE.SphereGeometry(radius, 16, 12);
                    const mat = new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        roughness: 0.9,
                        metalness: 0.0
                    });
                    const puff = new THREE.Mesh(geo, mat);

                    // random offsets so the puffs aren't symmetric 
                    puff.position.set(
                        (Math.random() - 0.5) * 1.6, // left/right 
                        (Math.random() - 0.5) * 0.4, // up/down 
                        (Math.random() - 0.5) * 0.6 // front/back 
                    );
                    cloud.add(puff);
                }

                // position the entire cloud somewhere in the sky
                cloud.position.set(
                    (Math.random() - 0.5) * CLOUD_SPREAD_X, // x spread
                    CLOUD_HEIGHT + (Math.random() - 0.5) * 1.5, // slight y variation
                    THREE.MathUtils.randFloat(CLOUD_MIN_Z, CLOUD_MAX_Z) // random depth
                );

                cloud.scale.set(
                    1.5 + Math.random() * 2.0, // width
                    1.0 + Math.random() * 0.5, // height
                    1.0 + Math.random() * 0.3 // depth
                ); // slightly stretch cloud to get more of a cloud-effect

                cloud.userData.speed = THREE.MathUtils.randFloat(0.5, 2.0); // each cloud moves at diff speeds
                cloud.userData.dir = Math.random() < 0.5 ? -1 : 1; // left or right

                return cloud;
            }

            // function for the rain
            function createRain() {
                rainGroup = new THREE.Group();
                // buffer geometry to hold positions of all raindrops
                const positions = new Float32Array(RAIN_COUNT * 3);

                for (let i = 0; i < RAIN_COUNT; i++) {
                    const idx = i * 3;
                    // random x/z within a square area around origin
                    positions[idx + 0] = (Math.random() - 0.5) * RAIN_AREA_XZ; // x
                    positions[idx + 1] = Math.random() * RAIN_HEIGHT + 2; // y
                    positions[idx + 2] = (Math.random() - 0.5) * RAIN_AREA_XZ; // z
                }

                const rainGeo = new THREE.BufferGeometry();
                rainGeo.setAttribute(
                    'position',
                    new THREE.BufferAttribute(positions, 3)
                );

                const rainMat = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 0.06,     // screen space size of each drop
                    transparent: true,
                    opacity: 0.9
                })

                const rainPoints = new THREE.Points(rainGeo, rainMat);
                rainGroup.add(rainPoints);
                scene.add(rainGroup);
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            function onKeyDown(event) {
                // toggle with r key
                if (event.key === 'r' || event.key === 'R') {
                    isRaining = !isRaining;
                    // toggle rain visibility
                    if (rainGroup) {
                        rainGroup.visible = isRaining;
                    }

                    if (isRaining){
                        renderer.setClearColor(0x6bb0d8, 1); // darker blue sky when raining
                    } else {
                        renderer.setClearColor(0x87ceeb, 1); // sky blue original
                    }
                }
            }

            // animation loop
            function animate() {
                requestAnimationFrame(animate);

                const t = clock.getElapsedTime(); // get time

                // frame delta time
                const delta = t - lastTime;
                lastTime = t;

                // sine wave for the wing flapping
                const flapOffset = Math.sin(t * FLAP_SPEED) * FLAP_AMPLITUDE;

                // ----- bird bobbing and flapping -----
                if (birdLoaded && birdGroup) {
                    const bob = Math.sin(t * BOB_SPEED) * BOB_AMPLITUDE;
                    birdGroup.position.y = baseBirdHeight + bob;

                }

                if (leftwing && rightwing) {
                    leftwing.rotation.x = baseLeftWingRoot + flapOffset;
                    rightwing.rotation.x = baseRightWingRoot - flapOffset;
                }

                // cloud animation
                if (clouds.length > 0) {
                    for (const cloud of clouds){
                        cloud.position.x += CLOUD_SPEED * delta; // drift slowly to the right

                        // move cloud according to its own speed/direction
                        cloud.position.x += cloud.userData.speed * cloud.userData.dir * delta;

                        // wrap clouds moving right
                        if (cloud.userData.dir > 0 && cloud.position.x > CLOUD_SPREAD_X * 0.5) {
                            cloud.position.x = -CLOUD_SPREAD_X * 0.5;
                        }

                        // wrap clouds moving left
                        if (cloud.userData.dir < 0 && cloud.position.x < -CLOUD_SPREAD_X * 0.5) {
                            cloud.position.x = CLOUD_SPREAD_X * 0.5;
                        }
                    }
                }

                // animate raindrops
                if (isRaining && rainGroup) {
                    const rainPoints = rainGroup.children[0];
                    const positions = rainPoints.geometry.attributes.position.array;

                    const RAIN_FALL_SPEED = 10.0;

                    // move each drop down by speed * delta
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i + 1] -= RAIN_FALL_SPEED * delta; // i + 1 is the y position

                        // if the rain falls below a certain height, respwn it at the top
                        if (positions[i + 1] < 0) {
                            positions[i + 1] = RAIN_HEIGHT;

                            // randomize x/z slightly when respawning
                            positions[i + 0] = (Math.random() - 0.5) * RAIN_AREA_XZ;
                            positions[i + 2] = (Math.random() - 0.5) * RAIN_AREA_XZ;
                        }
                    }
                    rainPoints.geometry.attributes.position.needsUpdate = true; // inform three.js of position changes
                }

                if (controls) controls.update();
                renderer.render(scene, camera);
            }
        </script>
    </body>
</html>